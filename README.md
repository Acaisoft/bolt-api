# ACAIâš¡BOLT API

This repo holds the microservice gluing together the bolt-deployer, bolt-wrapper, hasura, database 
and keycloak services. 

Note: Use `git clone --recurse-submodules <reponame>` to pull dependencies 
while cloning, or `git submodule update --init --recursive` from within project dir 
to fetch dependencies after cloning.

### Development

Almost everything needed to run bolt-api in development mode is contained in
`docker-compose` file, it should be enough to just execute:

```
docker-compose up
```

in root directory of this repo, then open a connection to the `bolt-deployer` service:

```
kubectl -n bolt-deployer port-forward svc/bolt-deployer 7777:80
``` 

(Make sure you connect to bolt-deployer in dev/correct k8 environment).

This starts hasura on http://localhost:8080 and bolt-api on http://localhost:5000.

To connect to hasura and have your changes recorded:

* `cd hasura`
* `hasura-cli console`

That opens a proxy to hasura listening on http://localhost:9695 with bolt-api as it's remote-schema.

To call bolt-api endpoints either open builtin graphiql console at http://localhost:5000/graphql
or open hasura's console at http://localhost:9695/api-explorer 

Documentation is contained and self-served in graphql schema, use one of the graphiql interfaces
(listed above) to peruse.

### Graphql queries and mutations

##### Hasura

A large set of graphql methods is made available by hasura for CRUD operation without employing bolt-api
where possible, these have their permissions set appropriately.
For these permissions to work correctly, the user request must identify to hasura using jwt
token prepared by keyclock per hasura documentation *but* with two required fields:

* `x-hasura-user-id` - contains unique user UUID generated by keycloak/authenticator,
* `x-hasura-default-role` - one of `admin`, `manager` or `reader`.

The UUID should be matched in `user_projects` table to grant access to specific projects.

##### Bolt-API

Where hasura methods are insufficient, bolt-api provides a superset of methods:

###### Queries:

* `testrun_repository_key` - returns id_rsa.pub key used by bolt-deployer
* `testrun_status` - checks test execution status with bolt-deployer, updates `execution` table details accordingly

###### Mutations:

* `testrun_project_create` - high-level interface to create and validate a project
* `testrun_project_create_validate` - as above, validation only
* `testrun_repository_create`
* `testrun_repository_create_validate`
* `testrun_repository_update`
* `testrun_repository_update_validate`
* `testrun_configuration_create`
* `testrun_configuration_create_validate`
* `testrun_configuration_update`
* `testrun_configuration_update_validate`
* `testrun_start` - given a configuration id, start actual tests (pass result to `testrun_status`)

##### Authentication in development

In debug mode developers can use:

* `oauth_conf` - exposes configured oauth client ids
* `oauth_authtoken` - exchanges oauth auth-token for a hasura jwt token
* http://localhost:5000/google/login and http://localhost:5000/github/login helper urls 

to perform oauth authentication, sufficient for testing permissions. 

### Project organization

* `/app/` - bolt-api flask server, use `flask run` to start in development mode or `/wsgi.py`
* `/bolt-deployer/` - git submodule, enabes integration with bolt-api through `bolt-deployer/sdk`
* `/bolt_api/` - python module containing common bolt-api graphql libraries and utilities  
* `/charts/` - helm deployment charts
* `/dev_setup/` - scratchpad area, populates fresh hasura instance with lots of data
* `/hasura/` - holds hasura migrations, schema definitions, and hasura-cli configuration
* `/instance/` - holds flask configuration, override with `CONFIG_FILE_PATH` and `SECRETS_FILE_PATH` env variables
* `/requirements/` - pip install -r core.txt

### Production Setup & Deployment

Dockerfile in project root is a reference point for any deployment, with bolt-api configuration 
controlled by `CONFIG_FILE_PATH` and `SECRETS_FILE_PATH` env variables.

Deployment requirements:

* redis
* hasura
* `pip install -r requirements/core.txt`
* environment variables:
    * `PORT` 
    run wsgi on this
    * `HASURA_GRAPHQL_ACCESS_KEY` 
    to authorize as service-account with, hasura instance access_key must equal this
    * `HASURA_GQL` 
    full address of hasura, eg. http://localhost:8080/v1alpha1/graphql
    * `REDIS_HOST` and `REDIS_PORT` and `REDIS_DB`
    * `BUCKET_PUBLIC_UPLOADS`
    path to Google Cloud Storage bucket for uploads ment to be public
    * `GOOGLE_APPLICATION_CREDENTIALS` 
    path to google service account credentials json file, 
    necessary for uploads 
* app configuration in `instance/conf.py`:
    * `GOOGLE_CLIENT_ID` and `GOOGLE_CLIENT_SECRET` 
    from https://console.cloud.google.com/apis/credentials/oauthclient/
    * `GITHUB_CLIENT_ID` and `GITHUB_CLIENT_SECRET` 
    from https://github.com/settings/applications/
    * `OAUTH_REDIRECT` 
    base address to redirect oauth responses to, 
    must be common for all oauth app providers, will most likely point to a frontend 
    address, eg.:
    if redirect address is configured in app is:  
    https://appfrontend.appspot.com/google/auth
    then OAUTH_REDIRECT will be https://appfrontend.appspot.com
    * `SECRET_KEY` 
    really secret, used for signing and verifying jwt tokens
    * `JWT_ALGORITHM` 
    defaults to `HS256`

### Startup sequence

#### Preparation

###### Hasura:

* set `HASURA_GRAPHQL_ACCESS_KEY` equal to api's
* set `BOLT_API_GRAPHQL` to bolt-api graphql address, eg. `http://api:5000/graphql`
* set `BOLT_API_CONFIGURATION_PARAM_CHANGE` and `BOLT_API_EXECUTION_STATE_CHANGE`
 to full paths of webhooks, eg. `http://api:5000/webhooks/execution/update`

###### DB:

Once hasura and db are up, go into `hasura` subfolder, 
adjust `endpoint` in `hasura/config.yaml` and execute hasura CLI tool:
```
/bin/hasura migrate apply
```

###### Services:

Start redis and db first, then api, then hasura.

Port forward to bolt-deployer using:
```
kubectl -n dev-bolt-deployer port-forward svc/bolt-deployer 7777:80
```

Order is important.

##### Remote schema:

Hasura migrations (see DB) set up bolt-api as remote schema thus offloading access and authorization 
to hasura. Bolt-api queries and mutations can be distinguished by the `testrun_` prefix.

### File Uploads

Files are uploaded directly to designated GCS buckets, through time-limited urls.

Upload processing (currently only image resizing) uses a bucket object change notification to listen to 
and react to changes. This feature requires a service account with both write and read access to pub/sub
and a correctly configured notification, see :[https://cloud.google.com/storage/docs/reporting-changes]
or simply:
```bash
gsutil notification create -t uploads-bolt-acaisoft -f json gs://uploads-bolt-acaisoft
```

To test uploads e2e:
```bash
flask upload_file --path /tmp/file.jpg
```
Then check for errors and if scaled versions are available.

To perform an upload manually:

* generate `Content-MD5` standard header for file being uploaded:
```
$ cat file_to_upload.jpg | openssl dgst -md5 -binary  | openssl enc -base64

xoK7oR4ezmKgX243mDbWuw==
```
* request an upload/download url from api, eg. for a project logo:
```
$response = mutation{
  testrun_project_image_upload (
    id:"d85d29e5-8204-46a7-8218-40bdcf68c978"
    content_type:"image/jpeg"
    content_md5:"xoK7oR4ezmKgX243mDbWuw=="
  ) {
    returning {
      id
      upload_url
      download_url
    }
  }
}
```
* upload the file, eg.:
```
curl \
    -X PUT \
    -H "Content-Type: image/jpeg" \
    -H "Content-MD5: xoK7oR4ezmKgX243mDbWuw==" \
    -T - {$response.returning.upload_url} < file_to_upload.jpg
```
* after successful upload, update the image_url in database:
```
mutation {
  testrun_project_update(
    id:"d85d29e5-8204-46a7-8218-40bdcf68c978"
    image_url:"{$response.returning.download_url}"
  ) { affected_rows }
}
```