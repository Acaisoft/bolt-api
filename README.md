# ACAIâš¡BOLT API

This repo holds the microservice gluing together the bolt-deployer, bolt-wrapper, hasura, database 
and keycloak services. 

Note: Use `git clone --recurse-submodules <reponame>` to pull dependencies 
while cloning, or `git submodule update --init --recursive` from within project dir 
to fetch dependencies after cloning.

### Development

Everything (except bolt-deployer - it lives inside cluster) needed to run bolt-api locally is contained in
`docker-compose` file, it should be enough to just execute:

```
docker-compose up
```

in root directory of this repo, then forward a port to the `bolt-deployer` service:

```
kubectl -n bolt-deployer port-forward svc/bolt-deployer 7777:80
``` 

(Make sure you connect to bolt-deployer in dev/correct k8 environment).

This starts hasura on http://localhost:8080 and bolt-api on http://localhost:5000.

To connect to hasura and have your changes recorded:

* `cd hasura`
* `hasura-cli console`

That opens a proxy to hasura listening on http://localhost:9695 with bolt-api as it's remote-schema.

To call bolt-api endpoints either open builtin graphiql console at http://localhost:5000/graphql
or open hasura's console at http://localhost:9695/api-explorer 

Documentation is contained and self-served in graphql schema, use one of the graphiql interfaces
(listed above) to peruse.

### Graphql queries and mutations

##### Hasura

A large set of graphql methods is made available by hasura for CRUD operation without employing bolt-api
where possible, these have their permissions set appropriately.
For these permissions to work correctly, the user request must identify to hasura using jwt
token prepared by keyclock per hasura documentation *but* with two required fields:

* `x-hasura-user-id` - contains unique user UUID generated by keycloak/authenticator,
* `x-hasura-default-role` - one of `admin`, `manager` or `reader`.

The UUID should be matched in `user_projects` table to grant access to specific projects.

##### Bolt-API

Where hasura methods are insufficient, bolt-api provides a superset of methods:

###### Queries:

* `testrun_repository_key` - returns id_rsa.pub key used by bolt-deployer
* `testrun_status` - checks test execution status with bolt-deployer, updates `execution` table details accordingly

###### Mutations:

* `testrun_project_create` - high-level interface to create and validate a project
* `testrun_project_create_validate` - as above, validation only
* `testrun_repository_create`
* `testrun_repository_create_validate`
* `testrun_repository_update`
* `testrun_repository_update_validate`
* `testrun_configuration_create`
* `testrun_configuration_create_validate`
* `testrun_configuration_update`
* `testrun_configuration_update_validate`
* `testrun_start` - given a configuration id, start actual tests (pass result to `testrun_status`)

For current list check graphiql interface.

##### Authentication in development

Hasura setup in docker-compose uses a token literal of `devaccess`, use that to authenticate per Hasura docs.

### Project organization

* `/apps/bolt_api/` - bolt-api flask server, forwarded as remote hasura chema, use `flask run` to start in development mode or `./wsgi.py`
    * `/apps/bolt_api/app/appgraph` - contains graphql mutations and queries
    * `/apps/bolt_api/app/webhooks` - contains public (!) endpoints for hasura to call on configured events, list with `flask routes`
* `/apps/bolt_metrics_api/` - metrics exporter for offloading and separating heavy tasks
* `/bolt-deployer/` - git submodule, enabes integration with bolt-api through `pip install bolt-deployer/sdk`
* `/charts/` - helm deployment charts
* `/cmds/` - helper flask commands list with `flask --help`  
* `/instance/` - flask configuration, override with `CONFIG_FILE_PATH` and `SECRETS_FILE_PATH` env variables
* `/services/` - python module containing core functionality  
* `/subsystems/` - holds hasura migrations, schema definitions, and hasura-cli configuration
* `/requirements.txt` - installs development requirements

### Production Setup & Deployment

Dockerfile in project root is a reference point for any deployment, with bolt-api configuration 
controlled by `CONFIG_FILE_PATH` and `SECRETS_FILE_PATH` env variables.

Deployment requirements:

* python >= 3.6 venv
* redis
* hasura
* `pip install -r requirements.txt`
* project configuration variables:
    * by default are read from `/instance/localhost-config.py` and `/instance/secrets.py`
    * conf files locations are configurable through `CONFIG_FILE_PATH` and `SECRETS_FILE_PATH` environment variables
    * missing but required config variables are checked at startup
    * external services necessary for operation are loaded eagerly where possible, with Hasura being notable exception
    (Hasura starts _after_ bolt_api) 

### Manual Startup Sequence

#### Preparation

###### Hasura:

* set `HASURA_GRAPHQL_ACCESS_KEY` equal to api's
* set `BOLT_API_GRAPHQL` to bolt-api graphql address, eg. `http://api:5000/graphql`
* set `BOLT_API_CONFIGURATION_PARAM_CHANGE` and `BOLT_API_EXECUTION_STATE_CHANGE`
 to full paths of webhooks, eg. `http://api:5000/webhooks/execution/update`

###### DB:

Once hasura and db are up, go into `/subsystems/hasura/` subfolder, 
adjust `endpoint` in `hasura/config.yaml` and execute hasura CLI tool:
```
/bin/hasura migrate apply
```

###### Services:

Start redis and db first, then api, then hasura, finally any monitoring.

Port forward to bolt-deployer using:
```
kubectl -n dev-bolt-deployer port-forward svc/bolt-deployer 7777:80
```

Order is important.

##### Remote schema:

Hasura migrations (see DB) set up bolt-api as remote schema thus offloading access and authorization 
to hasura. Bolt-api queries and mutations are to be distinguished by the `testrun_` prefix.

### File Uploads

Files are uploaded directly to designated GCS buckets, through time-limited signed urls.

Mutations accept 

To test uploads e2e:
```bash
flask upload_file --path /tmp/file.jpg
```
Then check for errors and if scaled versions are available.

To perform an upload manually:

* generate `Content-MD5` standard header for file being uploaded:
```
$ cat file_to_upload.jpg | openssl dgst -md5 -binary  | openssl enc -base64

xoK7oR4ezmKgX243mDbWuw==
```
* request an upload/download url from api, eg. for a project logo:
```
$response = mutation{
  testrun_project_image_upload (
    id:"d85d29e5-8204-46a7-8218-40bdcf68c978"
    content_type:"image/jpeg"
    content_md5:"xoK7oR4ezmKgX243mDbWuw=="
  ) {
    returning {
      id
      upload_url
      download_url
    }
  }
}
```
* upload the file, eg.:
```
curl \
    -X PUT \
    -H "Content-Type: image/jpeg" \
    -H "Content-MD5: xoK7oR4ezmKgX243mDbWuw==" \
    -T - {$response.returning.upload_url} < file_to_upload.jpg
```
* after successful upload, update the image_url in database:
```
mutation {
  testrun_project_update(
    id:"d85d29e5-8204-46a7-8218-40bdcf68c978"
    image_url:"{$response.returning.download_url}"
  ) { affected_rows }
}
```