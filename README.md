# ACAIâš¡BOLT API

### Development

Almost everything needed to run bolt-api in development mode is contained in
`docker-compose` file, it should be enough to just execute:

```
docker-compose up
```

in root directory of this repo, then open a connection to the `bolt-deployer` service:

```
kubectl -n bolt-deployer port-forward svc/bolt-deployer 7777:80
``` 

(Make sure you connect to bolt-deployer in dev/correct k8 environment).

This starts hasura on http://localhost:8080 and bolt-api on http://localhost:5000.

To connect to hasura and have your changes recorded:

* `cd hasura`
* `hasura-cli console`

That opens a proxy to hasura listening on http://localhost:9695 with bolt-api as it's remote-schema.

To call bolt-api endpoints either open builtin graphiql console at http://localhost:5000/graphql
or open hasura's console at http://localhost:9695/api-explorer 

Documentation is contained and self-served in graphql schema, use one of the graphiql interfaces
(listed above) to peruse.

### Graphql queries and mutations

##### Hasura

A large set of graphql methods is made available by hasura for CRUD operation without employing bolt-api
where possible, these have their permissions set appropriately.
For these permissions to work correctly, the user request must identify to hasura using jwt
token prepared by keyclock per hasura documentation *but* with two required fields:

* `x-hasura-user-id` - contains unique user UUID generated by keycloak/authenticator,
* `x-hasura-default-role` - one of `admin`, `manager` or `reader`.

The UUID should be matched in `user_projects` table to grant access to specific projects.

##### Bolt-API

Where hasura methods are insufficient, bolt-api provides a superset of methods:

###### Queries:

* `testrun_repository_key` - returns id_rsa.pub key used by bolt-deployer
* `testrun_status` - checks test execution status with bolt-deployer, updates `execution` table details accordingly

###### Mutations:

* `testrun_project_create` - high-level interface to create and validate a project
* `testrun_project_validate` - as above, validation only
* `testrun_repository_create`
* `testrun_repository_validate`
* `testrun_configuration_create`
* `testrun_configuration_validate`
* `testrun_start` - given a configuration id, start actual tests (pass result to `testrun_status`)

##### Authentication in development

In debug mode developers can use:

* `oauth_conf` - exposes configured oauth client ids
* `oauth_authtoken` - exchanges oauth auth-token for a hasura jwt token
* http://localhost:5000/google/login and http://localhost:5000/github/login helper urls 

to perform oauth authentication, sufficient for testing permissions. 

### Project organization

* `/app/` - bolt-api flask server, use `flask run` to start in development mode or `/wsgi.py`
* `/bolt-deployer/` - git submodule, enabes integration with bolt-api through `bolt-deployer/sdk`
* `/bolt_api/` - python module containing common bolt-api graphql libraries and utilities  
* `/charts/` - helm deployment charts
* `/dev_setup/` - scratchpad area, populates fresh hasura instance with lots of data
* `/hasura/` - holds hasura migrations, schema definitions, and hasura-cli configuration
* `/instance/` - holds flask configuration, override with `CONFIG_FILE_PATH` and `SECRETS_FILE_PATH` env variables
* `/requirements/` - pip install -r core.txt

### Production Setup & Deployment

Dockerfile in project root is a reference point for any deployment, with bolt-api configuration 
controlled by `CONFIG_FILE_PATH` and `SECRETS_FILE_PATH` env variables.

Deployment requirements:

* redis
* hasura
* `pip install -r requirements/core.txt`
* environment variables:
    * `PORT` 
    run wsgi on this
    * `HASURA_GRAPHQL_ACCESS_KEY` 
    to authorize as service-account with, hasura instance access_key must equal this
    * `HASURA_GQL` 
    full address of hasura, eg. http://localhost:8080/v1alpha1/graphql
    * `REDIS_HOST` and `REDIS_PORT` and `REDIS_DB`
* app configuration in `instance/conf.py`:
    * `GOOGLE_CLIENT_ID` and `GOOGLE_CLIENT_SECRET` 
    from https://console.cloud.google.com/apis/credentials/oauthclient/
    * `GITHUB_CLIENT_ID` and `GITHUB_CLIENT_SECRET` 
    from https://github.com/settings/applications/
    * `OAUTH_REDIRECT` 
    base address to redirect oauth responses to, 
    must be common for all oauth app providers, will most likely point to a frontend 
    address, eg.:
    if redirect address is configured in app is:  
    https://appfrontend.appspot.com/google/auth
    then OAUTH_REDIRECT will be https://appfrontend.appspot.com
    * `SECRET_KEY` 
    really secret, used for signing and verifying jwt tokens
    * `JWT_ALGORITHM` 
    defaults to `HS256`

### Startup sequence

#### Preparation

###### Hasura:

* set `HASURA_GRAPHQL_ACCESS_KEY` equal to api's
* set `BOLT_API_GRAPHQL` to bolt-api graphql address, eg. `http://api:5000/graphql`
* execute `tools/encode_jwt_secret.py` and store result in `HASURA_GRAPHQL_JWT_SECRET`, eg.:
```
HASURA_GRAPHQL_JWT_SECRET: '{"type": "HS256", "key": "jwtsigningksecretkey"}'
```

###### DB:

Once hasura and db are up, go into `hasura` subfolder, 
adjust `endpoint` in `hasura/config.yaml` and execute hasura CLI tool:
```
/bin/hasura migrate apply
```

###### Services:

Start redis and db first, then api, then hasura.

Port forward to bolt-deployer using:
```
kubectl -n dev-bolt-deployer port-forward svc/bolt-deployer 7777:80
```

Order is important.

##### Remote schema:

Hasura migrations (see DB) set up bolt-api as remote schema thus offloading access and authorization 
to hasura. Bolt-api queries and mutations can be distinguished by the `testrun_` prefix.

